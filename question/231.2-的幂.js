/*
 * @lc app=leetcode.cn id=231 lang=javascript
 *
 * [231] 2 的幂
 */
// @lc code=start
/**
 * @param {number} n
 * @return {boolean}
 */
 var isPowerOfTwo = function(n) {
    return n > 0 && (n & (n - 1)) === 0;
};

// 方法一：二进制表示
// 思路与算法

// 一个数 nn 是 22 的幂，当且仅当 nn 是正整数，并且 nn 的二进制表示中仅包含 11 个 11。

// 因此我们可以考虑使用位运算，将 nn 的二进制表示中最低位的那个 11 提取出来，再判断剩余的数值是否为 00 即可。下面介绍两种常见的与「二进制表示中最低位」相关的位运算技巧。

// 第一个技巧是

// \texttt{n \& (n - 1)}
// n & (n - 1)

// 其中 \texttt{\&}& 表示按位与运算。该位运算技巧可以直接将 nn 二进制表示的最低位 11 移除，它的原理如下：

// 假设 nn 的二进制表示为 (a 10\cdots 0)_2(a10⋯0) 
// 2
// ​
//  ，其中 aa 表示若干个高位，11 表示最低位的那个 11，0\cdots 00⋯0 表示后面的若干个 00，那么 n-1n−1 的二进制表示为：

// (a 01\cdots1)_2
// (a01⋯1) 
// 2
// ​
 

// 我们将 (a 10\cdots 0)_2(a10⋯0) 
// 2
// ​
//   与 (a 01\cdots1)_2(a01⋯1) 
// 2
// ​
//   进行按位与运算，高位 aa 不变，在这之后的所有位都会变为 00，这样我们就将最低位的那个 11 移除了。

// 因此，如果 nn 是正整数并且 \texttt{n \& (n - 1) = 0}n & (n - 1) = 0，那么 nn 就是 22 的幂。

// 第二个技巧是

// \texttt{n \& (-n)}
// n & (-n)

// 其中 -n−n 是 nn 的相反数，是一个负数。该位运算技巧可以直接获取 nn 二进制表示的最低位的 11。

// 由于负数是按照补码规则在计算机中存储的，-n−n 的二进制表示为 nn 的二进制表示的每一位取反再加上 11，因此它的原理如下：

// 假设 nn 的二进制表示为 (a 10\cdots 0)_2(a10⋯0) 
// 2
// ​
//  ，其中 aa 表示若干个高位，11 表示最低位的那个 11，0\cdots 00⋯0 表示后面的若干个 00，那么 -n−n 的二进制表示为：

// (\bar{a} 01\cdots1)_2 + (1)_2 = (\bar{a} 10\cdots0)_2
// ( 
// a
// ˉ
//  01⋯1) 
// 2
// ​
//  +(1) 
// 2
// ​
//  =( 
// a
// ˉ
//  10⋯0) 
// 2
// ​
 

// 其中 \bar{a} 
// a
// ˉ
//   表示将 aa 每一位取反。我们将 (a 10\cdots 0)_2(a10⋯0) 
// 2
// ​
//   与 (\bar{a} 10\cdots0)_2( 
// a
// ˉ
//  10⋯0) 
// 2
// ​
//   进行按位与运算，高位全部变为 00，最低位的 11 以及之后的所有 00 不变，这样我们就获取了 nn 二进制表示的最低位的 11。

// 因此，如果 nn 是正整数并且 \texttt{n \& (-n) = n}n & (-n) = n，那么 nn 就是 22 的幂。

// 作者：LeetCode-Solution
// 链接：https://leetcode-cn.com/problems/power-of-two/solution/2de-mi-by-leetcode-solution-rny3/
// 来源：力扣（LeetCode）
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
// @lc code=end
console.log(isPowerOfTwo(1))